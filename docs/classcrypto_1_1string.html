<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UDP-WG Implementation: crypto::string Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UDP-WG Implementation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecrypto.html">crypto</a></li><li class="navelem"><a class="el" href="classcrypto_1_1string.html">string</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcrypto_1_1string-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">crypto::string Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A cryptographically secure string.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="crypto_8h_source.html">crypto.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade4c497a1086a4ebedf6a2d050b0086b" id="r_ade4c497a1086a4ebedf6a2d050b0086b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade4c497a1086a4ebedf6a2d050b0086b">string</a> (const size_t &amp;l=0)</td></tr>
<tr class="memdesc:ade4c497a1086a4ebedf6a2d050b0086b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string with a fixed, zeroed size.  <br /></td></tr>
<tr class="separator:ade4c497a1086a4ebedf6a2d050b0086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695f75a2121287e2bf018930c5bc428a" id="r_a695f75a2121287e2bf018930c5bc428a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a695f75a2121287e2bf018930c5bc428a">string</a> (const std::string &amp;<a class="el" href="classcrypto_1_1string.html">string</a>)</td></tr>
<tr class="memdesc:a695f75a2121287e2bf018930c5bc428a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from a std::string.  <br /></td></tr>
<tr class="separator:a695f75a2121287e2bf018930c5bc428a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990fbea82de240a989513a8afee4c2b7" id="r_a990fbea82de240a989513a8afee4c2b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a990fbea82de240a989513a8afee4c2b7">string</a> (const unsigned char *<a class="el" href="classcrypto_1_1string.html">string</a>, const size_t &amp;l)</td></tr>
<tr class="memdesc:a990fbea82de240a989513a8afee4c2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from a character array and size.  <br /></td></tr>
<tr class="separator:a990fbea82de240a989513a8afee4c2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a208e0fd5475c1ee878acca344ccc7" id="r_a47a208e0fd5475c1ee878acca344ccc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47a208e0fd5475c1ee878acca344ccc7">string</a> (const char *<a class="el" href="classcrypto_1_1string.html">string</a>)</td></tr>
<tr class="memdesc:a47a208e0fd5475c1ee878acca344ccc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from a character array.  <br /></td></tr>
<tr class="separator:a47a208e0fd5475c1ee878acca344ccc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a9c9b8372508b15cdc25fe99dd3966" id="r_a00a9c9b8372508b15cdc25fe99dd3966"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00a9c9b8372508b15cdc25fe99dd3966">~string</a> ()</td></tr>
<tr class="memdesc:a00a9c9b8372508b15cdc25fe99dd3966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the string.  <br /></td></tr>
<tr class="separator:a00a9c9b8372508b15cdc25fe99dd3966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316f5779d8f120c1c08d7470dd49164b" id="r_a316f5779d8f120c1c08d7470dd49164b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a316f5779d8f120c1c08d7470dd49164b">substr</a> (const size_t &amp;start, const size_t &amp;count=std::string::npos) const</td></tr>
<tr class="memdesc:a316f5779d8f120c1c08d7470dd49164b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a subset of the string.  <br /></td></tr>
<tr class="separator:a316f5779d8f120c1c08d7470dd49164b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f8fe6d1b7f6fc3a788e18909c29ffe" id="r_a87f8fe6d1b7f6fc3a788e18909c29ffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87f8fe6d1b7f6fc3a788e18909c29ffe">resize</a> (const size_t &amp;n, const unsigned char &amp;v=0)</td></tr>
<tr class="memdesc:a87f8fe6d1b7f6fc3a788e18909c29ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the string.  <br /></td></tr>
<tr class="separator:a87f8fe6d1b7f6fc3a788e18909c29ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419d89764b11916066d338c495a86a68" id="r_a419d89764b11916066d338c495a86a68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a419d89764b11916066d338c495a86a68">append</a> (const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;s)</td></tr>
<tr class="memdesc:a419d89764b11916066d338c495a86a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append another string to end of the caller.  <br /></td></tr>
<tr class="separator:a419d89764b11916066d338c495a86a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76aa780224c4637f19543eb93d0e33d0" id="r_a76aa780224c4637f19543eb93d0e33d0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76aa780224c4637f19543eb93d0e33d0">str</a> ()</td></tr>
<tr class="memdesc:a76aa780224c4637f19543eb93d0e33d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hexadecimal representation of the <a class="el" href="classcrypto_1_1string.html" title="A cryptographically secure string.">crypto::string</a>.  <br /></td></tr>
<tr class="separator:a76aa780224c4637f19543eb93d0e33d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1df4da6bb9258c11380ab9792923b9" id="r_add1df4da6bb9258c11380ab9792923b9"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add1df4da6bb9258c11380ab9792923b9">length</a> () const</td></tr>
<tr class="memdesc:add1df4da6bb9258c11380ab9792923b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the string.  <br /></td></tr>
<tr class="separator:add1df4da6bb9258c11380ab9792923b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a67fcc9167bbd5b032cf3deaedaa6c2" id="r_a8a67fcc9167bbd5b032cf3deaedaa6c2"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a67fcc9167bbd5b032cf3deaedaa6c2">bytes</a> ()</td></tr>
<tr class="memdesc:a8a67fcc9167bbd5b032cf3deaedaa6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable byte array that can be directly manipulated.  <br /></td></tr>
<tr class="separator:a8a67fcc9167bbd5b032cf3deaedaa6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cafb1ded56bca79e28df9922bcbbb10" id="r_a2cafb1ded56bca79e28df9922bcbbb10"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cafb1ded56bca79e28df9922bcbbb10">bytes</a> () const</td></tr>
<tr class="memdesc:a2cafb1ded56bca79e28df9922bcbbb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a immutable byte array of the internal values.  <br /></td></tr>
<tr class="separator:a2cafb1ded56bca79e28df9922bcbbb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2aca422879540e85534db681bd71ff" id="r_a2d2aca422879540e85534db681bd71ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d2aca422879540e85534db681bd71ff">to</a> () const</td></tr>
<tr class="memdesc:a2d2aca422879540e85534db681bd71ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a std::string representation of the string.  <br /></td></tr>
<tr class="separator:a2d2aca422879540e85534db681bd71ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edb82cf6c249b5419d88f6c288a1b12" id="r_a8edb82cf6c249b5419d88f6c288a1b12"><td class="memItemLeft" align="right" valign="top">unsigned char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8edb82cf6c249b5419d88f6c288a1b12">operator[]</a> (const size_t &amp;pos)</td></tr>
<tr class="memdesc:a8edb82cf6c249b5419d88f6c288a1b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index the string.  <br /></td></tr>
<tr class="separator:a8edb82cf6c249b5419d88f6c288a1b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9161f1da89668ce5569210eb7b4d3a6" id="r_ab9161f1da89668ce5569210eb7b4d3a6"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9161f1da89668ce5569210eb7b4d3a6">operator==</a> (const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;cmp) const</td></tr>
<tr class="memdesc:ab9161f1da89668ce5569210eb7b4d3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalence operator.  <br /></td></tr>
<tr class="separator:ab9161f1da89668ce5569210eb7b4d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad7c3303731a3318a2b92247e0a4f77" id="r_a9ad7c3303731a3318a2b92247e0a4f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad7c3303731a3318a2b92247e0a4f77">operator+</a> (const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;a) const</td></tr>
<tr class="memdesc:a9ad7c3303731a3318a2b92247e0a4f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatonation operator.  <br /></td></tr>
<tr class="separator:a9ad7c3303731a3318a2b92247e0a4f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A cryptographically secure string. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Originally, the reason for this class' existence was because OpenSSL deals with unsigned characters, whereas the std::string deals with signed. Usually C++ is nice and will implicitly cast types, but apparently there are irreconciable differences between how these two datatypes are stored, and as such the ISO forbids implicit casting. Therefore, this object was little more than a std::string imitator that implemented the key functions, but with unsigned characters in the back, and with the ability to easily convert back and forth. However, this object quickly became ubiqutous, to the point that there was no reason to convert back to std::string. This provides an opportunity to make the object more cryptographically secure. In essence, all it does is zero any information that was stored in it during its destruction. I toyed with encrypting the stored data, perhaps using the time or something similar, but also didn't want to over complicated something that isn't the main focus of this project. I bring this up because it's strongly recommended not to use interpereted languages like Python or Shell Scripting Languages like Bash for cryptographic implementations, chiefly because their abstraction of memory makes it difficult to wipe sensitive data. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ade4c497a1086a4ebedf6a2d050b0086b" name="ade4c497a1086a4ebedf6a2d050b0086b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4c497a1086a4ebedf6a2d050b0086b">&#9670;&#160;</a></span>string() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">crypto::string::string </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a string with a fixed, zeroed size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The size of the object (It can still grow/shrink, but this allows us to pass it into memcpy where it expects a certain size). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is the wonderful reason why we can do <a class="el" href="classcrypto_1_1string.html" title="A cryptographically secure string.">crypto::string</a> a = 32, and have a 32 byte string. </dd></dl>

</div>
</div>
<a id="a695f75a2121287e2bf018930c5bc428a" name="a695f75a2121287e2bf018930c5bc428a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695f75a2121287e2bf018930c5bc428a">&#9670;&#160;</a></span>string() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">crypto::string::string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a string from a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a990fbea82de240a989513a8afee4c2b7" name="a990fbea82de240a989513a8afee4c2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990fbea82de240a989513a8afee4c2b7">&#9670;&#160;</a></span>string() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">crypto::string::string </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a string from a character array and size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The input string. </td></tr>
    <tr><td class="paramname">l</td><td>The size of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check if the provided size is bounded by the size of the string! </dd></dl>

</div>
</div>
<a id="a47a208e0fd5475c1ee878acca344ccc7" name="a47a208e0fd5475c1ee878acca344ccc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a208e0fd5475c1ee878acca344ccc7">&#9670;&#160;</a></span>string() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">crypto::string::string </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a string from a character array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used for constructing from string literals IE <a class="el" href="classcrypto_1_1string.html" title="A cryptographically secure string.">crypto::string</a> a = "Hello!"; </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function uses strlen to determine length. If your string is not null terminated, this function will read out of bounds! </dd></dl>

</div>
</div>
<a id="a00a9c9b8372508b15cdc25fe99dd3966" name="a00a9c9b8372508b15cdc25fe99dd3966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a9c9b8372508b15cdc25fe99dd3966">&#9670;&#160;</a></span>~string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">crypto::string::~string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the string. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Zeros the content. </dd>
<dd>
A brief aside on memory management, and an interesting feature of the STL (Or, in other words, skip this if you don't want to read a wall of C++ semantics) One utility that I use for every C/C++ program is Valgrind; basically, the dynamic memory allocators like malloc/calloc/realloc are prone to erroneous use, and this program will run underneath the one you've created, hooking those functions and reporting when you use them incorrectly (Failing to free dynamic memory, trying to free it twice, etc). These functions are often pointed to when people claim that C/C++ is a antiquated language, recommending instead the ridiculously slow Python, or the ridiculously convulted ownership/reference system of Rust (I speak from personal experience on both counts). In my, truthfully biased opinion, I don't consider this argument particularly compelling, because the dynamic memory functions work excellently, and errors arise not because of the language, but because of the the programmer using it. All that said, if you run Valgrind with this program, you'll notice some strange "Still Accessible" remarks, which technically aren't errors, or anything to worry about, but they all come from this class. I found this exceptionally confusing, because we don't use any dynamic allocators, we use the std::vector specifically to avoid manual memory handling. Turns out, one reason that the STL classes are so fast is because they pool memory between each other. In essence, the STL will create a a massive pool of memory allocated in one massive block at the start of the program run, and then everything from std::string, std::list, std::queue, and std::any will draw upon this pool, and will "free" it by simply setting it to nullptr. This is brilliant, not only because it could be done by something so prolifically used as the STL, but because it ensures a single allocation and free, effectively eliminating the issue of memory leaking, while improving performance. The only downside of this approach is that Valgrind wasn't built to understand this, so when the std::vector calls its destructor, Valgrind notices that there's still a handle to this pool, which could be indicative of having two pointers to the same dynamic address, freeing one, and then trying to access that freed memory with the second (Exceptionally bad). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a419d89764b11916066d338c495a86a68" name="a419d89764b11916066d338c495a86a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419d89764b11916066d338c495a86a68">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crypto::string::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append another string to end of the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a67fcc9167bbd5b032cf3deaedaa6c2" name="a8a67fcc9167bbd5b032cf3deaedaa6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a67fcc9167bbd5b032cf3deaedaa6c2">&#9670;&#160;</a></span>bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * crypto::string::bytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a mutable byte array that can be directly manipulated. </p>
<dl class="section return"><dt>Returns</dt><dd>The beginning of the string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This relies on the fact that vector's store their information contiguously: <a href="https://en.cppreference.com/w/cpp/container/vector">https://en.cppreference.com/w/cpp/container/vector</a> </dd></dl>

</div>
</div>
<a id="a2cafb1ded56bca79e28df9922bcbbb10" name="a2cafb1ded56bca79e28df9922bcbbb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cafb1ded56bca79e28df9922bcbbb10">&#9670;&#160;</a></span>bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * crypto::string::bytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a immutable byte array of the internal values. </p>
<dl class="section return"><dt>Returns</dt><dd>The byte array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Typically, function overloads (IE two functions with identical names) Cannot be solely distinguished by return type. This makes sense, because if you have two functions A(), and do something like auto ret = A(), the compiler has no way to know which version you wanted. However, constant overloads allow this. In essence, this function just means, if the <a class="el" href="classcrypto_1_1string.html" title="A cryptographically secure string.">crypto::string</a> is a constant value (IE const std::crypto my_string), then rather than returning a mutable character array (Which would circumvent the constant qualifier, and thus the compiler would refuse it), we return a constant pointer. </dd></dl>

</div>
</div>
<a id="add1df4da6bb9258c11380ab9792923b9" name="add1df4da6bb9258c11380ab9792923b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1df4da6bb9258c11380ab9792923b9">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t crypto::string::length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the length of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The length. </dd></dl>

</div>
</div>
<a id="a9ad7c3303731a3318a2b92247e0a4f77" name="a9ad7c3303731a3318a2b92247e0a4f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad7c3303731a3318a2b92247e0a4f77">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::string::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatonation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The caller concatenated with the input. </dd></dl>

</div>
</div>
<a id="ab9161f1da89668ce5569210eb7b4d3a6" name="ab9161f1da89668ce5569210eb7b4d3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9161f1da89668ce5569210eb7b4d3a6">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool crypto::string::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalence operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>The string to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the strings are equal. </dd></dl>

</div>
</div>
<a id="a8edb82cf6c249b5419d88f6c288a1b12" name="a8edb82cf6c249b5419d88f6c288a1b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edb82cf6c249b5419d88f6c288a1b12">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char &amp; crypto::string::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mutable byte at that position. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the position is out of bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87f8fe6d1b7f6fc3a788e18909c29ffe" name="a87f8fe6d1b7f6fc3a788e18909c29ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f8fe6d1b7f6fc3a788e18909c29ffe">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crypto::string::resize </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new size. </td></tr>
    <tr><td class="paramname">v</td><td>The character to use to fill new spaces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76aa780224c4637f19543eb93d0e33d0" name="a76aa780224c4637f19543eb93d0e33d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76aa780224c4637f19543eb93d0e33d0">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string crypto::string::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a hexadecimal representation of the <a class="el" href="classcrypto_1_1string.html" title="A cryptographically secure string.">crypto::string</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The hex string. </dd></dl>

</div>
</div>
<a id="a316f5779d8f120c1c08d7470dd49164b" name="a316f5779d8f120c1c08d7470dd49164b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316f5779d8f120c1c08d7470dd49164b">&#9670;&#160;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::string::substr </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a subset of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The left bound </td></tr>
    <tr><td class="paramname">count</td><td>The amount of characters to read from the left bound. std::string::npos means everything until the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The substring. </dd></dl>

</div>
</div>
<a id="a2d2aca422879540e85534db681bd71ff" name="a2d2aca422879540e85534db681bd71ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2aca422879540e85534db681bd71ff">&#9670;&#160;</a></span>to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string crypto::string::to </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a std::string representation of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The string. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="crypto_8h_source.html">crypto.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
