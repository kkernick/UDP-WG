<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UDP-WG Implementation: crypto Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UDP-WG Implementation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">crypto Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The cryptographic implementations for WireGuard.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrypto_1_1keypair.html">keypair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple private-public keypair.  <a href="classcrypto_1_1keypair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrypto_1_1string.html">string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cryptographically secure string.  <a href="classcrypto_1_1string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5604cd97b9b8a8170d9658486a504b56" id="r_a5604cd97b9b8a8170d9658486a504b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5604cd97b9b8a8170d9658486a504b56">DH</a> (const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;priv, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;pub)</td></tr>
<tr class="separator:a5604cd97b9b8a8170d9658486a504b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935cf6839d85c0bda03ac16691ebcbee" id="r_a935cf6839d85c0bda03ac16691ebcbee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1keypair.html">keypair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a935cf6839d85c0bda03ac16691ebcbee">DH_GENERATE</a> ()</td></tr>
<tr class="memdesc:a935cf6839d85c0bda03ac16691ebcbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Curve25519 keypair.  <br /></td></tr>
<tr class="separator:a935cf6839d85c0bda03ac16691ebcbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14babea0a043cb2ba38fa6c8407092" id="r_aee14babea0a043cb2ba38fa6c8407092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee14babea0a043cb2ba38fa6c8407092">IV</a> (uint64_t counter)</td></tr>
<tr class="memdesc:aee14babea0a043cb2ba38fa6c8407092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the IV array given the WireGuard Counter.  <br /></td></tr>
<tr class="separator:aee14babea0a043cb2ba38fa6c8407092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa49b0e725e70d83767ba70a1cc19aff" id="r_aaa49b0e725e70d83767ba70a1cc19aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa49b0e725e70d83767ba70a1cc19aff">ENCRYPT</a> (<a class="el" href="classcrypto_1_1string.html">string</a> key, const uint64_t &amp;counter, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;plain, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;data)</td></tr>
<tr class="memdesc:aaa49b0e725e70d83767ba70a1cc19aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt with ChaCha20-Poly1305.  <br /></td></tr>
<tr class="separator:aaa49b0e725e70d83767ba70a1cc19aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb67b539af31c0b2b7e0f3df80cd2711" id="r_aeb67b539af31c0b2b7e0f3df80cd2711"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb67b539af31c0b2b7e0f3df80cd2711">DECRYPT</a> (<a class="el" href="classcrypto_1_1string.html">string</a> key, const uint64_t &amp;counter, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;cipher, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;data)</td></tr>
<tr class="memdesc:aeb67b539af31c0b2b7e0f3df80cd2711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt with ChaCha20-Poly1305.  <br /></td></tr>
<tr class="separator:aeb67b539af31c0b2b7e0f3df80cd2711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdaae4ca3802724ceacfeeaeebb47a8" id="r_adcdaae4ca3802724ceacfeeaeebb47a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1keypair.html">keypair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcdaae4ca3802724ceacfeeaeebb47a8">XENCRYPT</a> (<a class="el" href="classcrypto_1_1string.html">string</a> key, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;plain, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;data)</td></tr>
<tr class="memdesc:adcdaae4ca3802724ceacfeeaeebb47a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt with XChaCha20-Poly1305.  <br /></td></tr>
<tr class="separator:adcdaae4ca3802724ceacfeeaeebb47a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1623d9532c0f1aebc2b3d132eab5d345" id="r_a1623d9532c0f1aebc2b3d132eab5d345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1623d9532c0f1aebc2b3d132eab5d345">XDECRYPT</a> (<a class="el" href="classcrypto_1_1string.html">string</a> key, const <a class="el" href="classcrypto_1_1keypair.html">keypair</a> &amp;pair, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;data)</td></tr>
<tr class="memdesc:a1623d9532c0f1aebc2b3d132eab5d345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt with XChaCha20-Poly1305.  <br /></td></tr>
<tr class="separator:a1623d9532c0f1aebc2b3d132eab5d345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eb096aad7838e4816dd45134ef1294" id="r_ab4eb096aad7838e4816dd45134ef1294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4eb096aad7838e4816dd45134ef1294">HASH</a> (const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;in)</td></tr>
<tr class="memdesc:ab4eb096aad7838e4816dd45134ef1294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a BLAKE2s256 Hash of the input.  <br /></td></tr>
<tr class="separator:ab4eb096aad7838e4816dd45134ef1294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93590339978542af71914668adf7e158" id="r_a93590339978542af71914668adf7e158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93590339978542af71914668adf7e158">HMAC</a> (const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;key, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;input, const size_t &amp;size=32)</td></tr>
<tr class="memdesc:a93590339978542af71914668adf7e158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an HMAC using BLAKE and a key.  <br /></td></tr>
<tr class="separator:a93590339978542af71914668adf7e158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69836de5f263cf7d45cdd7f2682290c" id="r_af69836de5f263cf7d45cdd7f2682290c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrypto_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69836de5f263cf7d45cdd7f2682290c">MAC</a> (const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;key, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;input)</td></tr>
<tr class="memdesc:af69836de5f263cf7d45cdd7f2682290c"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenSSL makes no difference between HMAC-BLAKE2s256 and Keyed BLAKE2s256 Besides setting the size. Therefore, we can reuse the same code, and just return the required 16 bytes, as opposed to the 32 expected from HMAC proper.  <br /></td></tr>
<tr class="separator:af69836de5f263cf7d45cdd7f2682290c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4581fd6066f56dafe6b46f080c2fddc6" id="r_a4581fd6066f56dafe6b46f080c2fddc6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcrypto_1_1string.html">string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4581fd6066f56dafe6b46f080c2fddc6">KDF</a> (const size_t &amp;n, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;key, const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;input)</td></tr>
<tr class="memdesc:a4581fd6066f56dafe6b46f080c2fddc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the HKDF scheme on our HMAC function.  <br /></td></tr>
<tr class="separator:a4581fd6066f56dafe6b46f080c2fddc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The cryptographic implementations for WireGuard. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Like the main file at <a class="el" href="wireguard_8h_source.html">wireguard.h</a>: this implementation was created in reference to the WireGuard Whitepaper (<a href="https://www.wireguard.com/papers/wireguard.pdf">https://www.wireguard.com/papers/wireguard.pdf</a>) herein referred to as the "Reference" </dd>
<dd>
Originally, I intended to implement all the cryptographic algorithms using OpenSSL. This would not only reduce the amount of dependencies, but effectively eliminate them as most Linux systems already have it. However, OpenSSL neither support XChaCha20-Poly1305, and it's Curve25519 was not giving me correct results. Therefore, these parts of the program have been implemented using libsodium, which, rather unfortunately, was also unable to provide all the required functions (It doesn't have BLAKE2s support). </dd>
<dd>
This namespace has the perk of showing both how to work with OpenSSL, and Sodium. The latter is much easier to work with, as OpenSSL's design of leasing dynamically allocated objects, checking the result of every call, and then having to free those objects is usually a pain to work with. Most solutions I've seen pick the lesser of two evils: Free all the resources within each error check, which clogs the code with duplication, or&ndash;worse&ndash;use goto statements to just jump to the end of the function. The approach I've taken is have each function be a wrapper for a lambda that makes all the OpenSSL calls (Or at least the ones that can give errors). The main function can then allocate everything, run the function, and then free everything afterwards, and the lambda is free to abort at any point back to the caller. This isn't really what lambdas were made for, but it makes the code cleaner, doesn't clutter the namespace with auxiliary functions,and ensures proper memory management and error checking. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aeb67b539af31c0b2b7e0f3df80cd2711" name="aeb67b539af31c0b2b7e0f3df80cd2711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb67b539af31c0b2b7e0f3df80cd2711">&#9670;&#160;</a></span>DECRYPT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::DECRYPT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrypto_1_1string.html">string</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>counter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cipher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt with ChaCha20-Poly1305. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The 32 byte key. </td></tr>
    <tr><td class="paramname">counter</td><td>The WireGuard counter. </td></tr>
    <tr><td class="paramname">cipher</td><td>The ciphertext. </td></tr>
    <tr><td class="paramname">data</td><td>The AAD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plaintext string </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the key/data are invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See <a href="https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/original_chacha20-poly1305_construction">https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/original_chacha20-poly1305_construction</a> </dd></dl>

</div>
</div>
<a id="a5604cd97b9b8a8170d9658486a504b56" name="a5604cd97b9b8a8170d9658486a504b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5604cd97b9b8a8170d9658486a504b56">&#9670;&#160;</a></span>DH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::DH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>priv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a Curve25519 point multiplication on the public and private key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keypair</td><td>The 32 byte public key and private key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32 byte product. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>See 5.4 of the Reference </dd>
<dd>
Curve25519 Point Multiplication has this really interesting property where if you have a two keypairs A and B, the result of DH(A_priv, B_pub) is equal to DH(B_priv, A_pub). This means, that by solely exchanging public keys, two peers can come to the same value by simply multiplying their private key against the received key. This is akin to how standard DH works (Hence the name), Where we share a public value which is a generator raised to our private key, and by raising this received value by our own private key, we come to the same value. </dd>
<dd>
Why does this work? In essence, the private key is a very large number that gets multiplied. to a generator (In this case the Curve25519 generator on its curve), which returns us a point on that curve that is our public key. The idea is that while multiplying the curve generator against the private number is very quick, trying to derive the original private key from only the public point requires tedious addition and is akin to the discrete logarithm problem. Let's try expanding our values (Note that operations like * and + are performed in GF(2**255 - 19):<ol type="1">
<li>A_pub = G * A_priv; B_pub = G * B_priv</li>
<li>DH(A_priv, B_pub) = DH(A_priv, G * B_priv) = A_priv * G * B_priv</li>
<li>DH(B_priv, A_pub) = DH(B_priv, G * A_priv) = B_priv * G * A_priv. And, thanks to the associative property of multiplication, we reach the same value. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a935cf6839d85c0bda03ac16691ebcbee" name="a935cf6839d85c0bda03ac16691ebcbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935cf6839d85c0bda03ac16691ebcbee">&#9670;&#160;</a></span>DH_GENERATE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1keypair.html">keypair</a> crypto::DH_GENERATE </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a Curve25519 keypair. </p>
<dl class="section return"><dt>Returns</dt><dd>{public,private} keypair of 32 bytes each. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>WireGuard identifies peers and the interface (IE the server) Via a Curve25519, 32-byte public key. This function uses Sodium to generate such a keypair. </dd>
<dd>
See Section 2 of the Reference. </dd>
<dd>
Curve25519 is what is called an "Elliptic Curve," and is the EC in ECC. It is literally a curve, derived from a mathematica functional: such as y = x**2. This curve in particular is: y**2 = x**3 + 486662(x**2) +x. So, how does this curve somehow generate a keypair? In my own personal readings, I found this video: <a href="https://www.youtube.com/watch?v=NF1pwjL9-DE">https://www.youtube.com/watch?v=NF1pwjL9-DE</a> to be very helpful, but I'll give you the summary: To generate a keypair, we first take a point on the curve, G which is the generator. Everyone knows this value, and its akin to the public g in Diffie-Hellman (Which is where the DH in these functions come from, if you're interested). Then, we generate a massive random number as our private key, and the idea is that you continually add the generator to itself which, due to the properties of the curve and the way you add (It's not complicated, I just don't want to make this more verbose than it already is), will leave you with a public value which is a point on that curve, which is your private key multiplied by the generator. We can easily calculate our public value from our private value and generator by simply doing pub = priv * gen (Curve Multiplication is very fast), but with only the public and generator values, the only way to find the private is by brute forcing adding the generator over and over again until you get the public value. </dd>
<dd>
The mathematics behind this is very similar to AES's GF(256), in fact, the name Curve25519 is because it's in GF(2**255 -19), and just like GF(256), this field requires special functions for mathematical operations, but is very fast (Hence why we can so quickly calculate pub*gen). I say this because when this used to be implemented in OpenSSL, I had to manually implement these operations. I based it off of another excellent source on the subject: <a href="https://martin.kleppmann.com/papers/curve25519.pdf">https://martin.kleppmann.com/papers/curve25519.pdf</a> but a combination of misusing OpenSSL's Curve25519 implementation, and trying to implement the operations myself, led to it not working, and I was able to reduce &gt; 200 lines and a custom class into four lines of code with libsodium. </dd></dl>

</div>
</div>
<a id="aaa49b0e725e70d83767ba70a1cc19aff" name="aaa49b0e725e70d83767ba70a1cc19aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa49b0e725e70d83767ba70a1cc19aff">&#9670;&#160;</a></span>ENCRYPT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::ENCRYPT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrypto_1_1string.html">string</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>counter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt with ChaCha20-Poly1305. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The 32 byte key key to use for encryption. </td></tr>
    <tr><td class="paramname">counter</td><td>The WireGuard Counter, for a nonce. </td></tr>
    <tr><td class="paramname">plain</td><td>The plaintext. </td></tr>
    <tr><td class="paramname">data</td><td>The AAD. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ciphertext </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This encryption scheme is like AES-CTR + HMAC, in that ChaCha20 is a cipher (stream, not block), and Poly1305 is a MAC that provides authentication. According to: <a href="https://en.wikipedia.org/wiki/ChaCha20-Poly1305">https://en.wikipedia.org/wiki/ChaCha20-Poly1305</a> It's actually faster than AES-GCM. The delightful name of ChaCha is in reference to the scheme that it is based on: Salsa20. They use Pseudo-Random number generators alongside Add-Rotate-XOR operations. Wikipedia provides a sample implementation (<a href="https://en.wikipedia.org/wiki/Salsa20">https://en.wikipedia.org/wiki/Salsa20</a>) that is a whole 32 lines. </dd>
<dd>
A stream cipher, like ChaCha20, differs from a block cipher, like AES, in that rather than applying a set of operations to blocks, like breaking a message into 16 byte states for AES, we instead generate a "keystream", which we treat as one, massive one-time pad that we can XOR against the entire message. So, rather than working on blocks, we work on each bit of the input, typically just XORing the bit against the corresponding position in the keystream. This lets us stream values, such as incoming packets, with a continuous keystream, which is perfect for network applications, where data is received in such streams. </dd>
<dd>
See <a href="https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/original_chacha20-poly1305_construction">https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/original_chacha20-poly1305_construction</a> </dd></dl>

</div>
</div>
<a id="ab4eb096aad7838e4816dd45134ef1294" name="ab4eb096aad7838e4816dd45134ef1294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eb096aad7838e4816dd45134ef1294">&#9670;&#160;</a></span>HASH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::HASH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a BLAKE2s256 Hash of the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The string to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 32 byte hash </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>See 5.4 of the Reference. </dd>
<dd>
BLAKE2 is neat, because it's a hashing algorithm that's based on the original BLAKE, which is based on an algorithm we've already seen: ChaCha. Wikipedia states what makes BLAKE different: "[A] permuted copy of the input block, XORed with round constants, is added before each ChaCha round." So, WireGuard is almost entirely based on the ChaCha algorithm, with Curve25519 for Key generation. BLAKE2 is also a really impressive algorithm: it's faster than MD5 and provides better security than SHA-2. There are two types: BLAKE2b, and BLAKE2s; Sodium does not implement the latter, but WireGuard requires it and as such we used OpenSSL for the implementation. Blake2s is specifically optimized for 32 bit computers. </dd>
<dd>
Using BLAKE2s is really a baffling decision, and despite my best efforts could not come up with a reason for why it was chosen. For context, BLAKE2b, despite using more rounds, is FASTER than BLAKE2s. The only advantage of BLAKE2s is that it's for 8-32 bit platforms, whereas BLAKE2b is 64 bits. This is the reason that Sodium doesn't have BLAKE2s support: It has no real advantage: <a href="https://github.com/jedisct1/libsodium/issues/531">https://github.com/jedisct1/libsodium/issues/531</a> "I'm very reluctant [to BLAKE2s], or more generally to adding anything that provides no value over what is already available." Now, perhaps the reason is to provide support for older, 32 bit systems. That's all well and good, except for the fact that we proflifically use 64 bit values, such as the WireGuard counter. Perhaps they did some benchmarking, but I struggle to see how using an algorithm designed for 64 bits on a 32 bit at handshake and rekey would be slower than doubling the needed clock cycles to update a counter that is updated on every message. Given that WireGuard is also touted as a modern VPN, I feel like supporting 32 bit machines is anthesis to that design philosophy. At the end of the day, it doesn't really make that much of a difference, it just means that I can't implement WireGuard exclusively through Sodium, which I was hoping for. </dd></dl>

</div>
</div>
<a id="a93590339978542af71914668adf7e158" name="a93590339978542af71914668adf7e158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93590339978542af71914668adf7e158">&#9670;&#160;</a></span>HMAC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::HMAC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">32</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an HMAC using BLAKE and a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The 32 byte key </td></tr>
    <tr><td class="paramname">input</td><td>The arbitrary sized input to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32 byte HMAC </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>See 5.4 of the Reference. </dd>
<dd>
A very neat part of BLAKE2 is that it is a "Keyed-Hash." This means that BLAKE2 directly supports providing a key alongside the data, returning a MAC without needing to use algorithms like HMAC that use a hash under the hood. </dd>
<dd>
This leads to a rather confusing section of the Reference, where it stipulates two functions: HMAC, which uses BLAKE in an HMAC construction, and MAC, which is BLAKE using it's self-keying functionality. OpenSSL's functionality is here: <a href="https://docs.openssl.org/3.3/man7/EVP_MAC-BLAKE2/">https://docs.openssl.org/3.3/man7/EVP_MAC-BLAKE2/</a> OpenSSL also has an HMAC section: <a href="https://docs.openssl.org/master/man3/HMAC">https://docs.openssl.org/master/man3/HMAC</a> Which politely tells you that it's deprecated and to instead use... <a href="https://docs.openssl.org/master/man3/EVP_MAC/">https://docs.openssl.org/master/man3/EVP_MAC/</a> So we're back at EVP_MAC-BLAKE2. I couldn't figure out why WireGuard stipulates the need for two separate MAC algorithms, especially when both are using the same Hashing algorithm under the hood, and the only thing I could think of is that HMAC returns 32 bytes, whereas MAC returns 16. I had a separate function that actually used the BLAKE2s keyed for MAC, and HMAC-BLAKE2s for HMAC, but I noticed that it returned the exact same thing, just truncated. So, to save myself the redundant code, MAC just returns a truncated HMAC. </dd></dl>

</div>
</div>
<a id="aee14babea0a043cb2ba38fa6c8407092" name="aee14babea0a043cb2ba38fa6c8407092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee14babea0a043cb2ba38fa6c8407092">&#9670;&#160;</a></span>IV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::IV </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>counter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format the IV array given the WireGuard Counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counter</td><td>The current WireGuard counter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>As per Section 5.4 of the Reference: "[The nonce is] composed of 32 bits of zeros followed by the 64-bit little-endian value of
counter" </dd>
<dd>
I have a suspicion that the reason for this format of the IV is the same reason as the counter used in AES-GCM. We want a 96 bit nonce as per ChaCha20's requirements, but there isn't exactly a 12 byte register for easily adding such a massive number. Therefore, we use the largest value that can actually be executed on in a modern system, 64 bits. Unlike GCM, however, 2**64 is such a monstrous number that there isn't much of a risk of the WireGuard counter overflowing. </dd></dl>

</div>
</div>
<a id="a4581fd6066f56dafe6b46f080c2fddc6" name="a4581fd6066f56dafe6b46f080c2fddc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4581fd6066f56dafe6b46f080c2fddc6">&#9670;&#160;</a></span>KDF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcrypto_1_1string.html">string</a> &gt; crypto::KDF </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the HKDF scheme on our HMAC function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The amount of rounds to run </td></tr>
    <tr><td class="paramname">key</td><td>The 32 byte key to use for the HMAC </td></tr>
    <tr><td class="paramname">input</td><td>The arbitrary sized input data for the HMAC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Vector containing N elements of 32 bytes each. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>See 5.4 of the Reference. </dd>
<dd>
This is the nice thing about having all the algorithms implemented. Since these build off each other, we don't even need to interface with OpenSSL to implement this. </dd>
<dd>
You may be concerned about how quickly this could become a monstrous output, but WireGuard never uses KDF with a n greater than 3. </dd>
<dd>
KDF works by taking an initial key and an input to derive a generation, and then subsequently creates new iterations from that initial state (Sort of like how AES' Key Schedule worked). The main idea between the algorithm is to get multiple keys from a single input, but another use I've seen is intentionally slowing down encryption to thwart attackers from repeatedly guessing. For example, the GRUB bootloader uses PBKDF for encrypting the passwords of users which is not to derive 50,000 separate keys, but to require more computation to get the password at the end. </dd></dl>

</div>
</div>
<a id="af69836de5f263cf7d45cdd7f2682290c" name="af69836de5f263cf7d45cdd7f2682290c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69836de5f263cf7d45cdd7f2682290c">&#9670;&#160;</a></span>MAC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::MAC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenSSL makes no difference between HMAC-BLAKE2s256 and Keyed BLAKE2s256 Besides setting the size. Therefore, we can reuse the same code, and just return the required 16 bytes, as opposed to the 32 expected from HMAC proper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The 32-byte key </td></tr>
    <tr><td class="paramname">input</td><td>The arbitrary input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>THe 16 byte MAC. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>My understanding of OpenSSL, and BLAKE2s, was that the 16 byte MAC was a fundamentally different operation than the normal 32 byte HMAC. We can tell OpenSSL the size of the resulting MAC via "size": <a href="https://docs.openssl.org/3.0/man7/EVP_MAC-BLAKE2/#supported-parameters">https://docs.openssl.org/3.0/man7/EVP_MAC-BLAKE2/#supported-parameters</a> But there was two problems with that: first, setting "size" caused a double-free, and second, printing out the MAC's revealed that OpenSSL was just truncating the output. Rather than use OpenSSL's unintuitive functions for setting size, we can do it ourselves and truncate the result to 16. </dd></dl>

</div>
</div>
<a id="a1623d9532c0f1aebc2b3d132eab5d345" name="a1623d9532c0f1aebc2b3d132eab5d345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1623d9532c0f1aebc2b3d132eab5d345">&#9670;&#160;</a></span>XDECRYPT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1string.html">string</a> crypto::XDECRYPT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrypto_1_1string.html">string</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1keypair.html">keypair</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pair</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt with XChaCha20-Poly1305. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The 32 byte key. </td></tr>
    <tr><td class="paramname">pair</td><td>The cipher + nonce </td></tr>
    <tr><td class="paramname">data</td><td>The AAD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plaintext string </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>See <a href="https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction">https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction</a> </dd></dl>

</div>
</div>
<a id="adcdaae4ca3802724ceacfeeaeebb47a8" name="adcdaae4ca3802724ceacfeeaeebb47a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdaae4ca3802724ceacfeeaeebb47a8">&#9670;&#160;</a></span>XENCRYPT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrypto_1_1keypair.html">keypair</a> crypto::XENCRYPT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrypto_1_1string.html">string</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt with XChaCha20-Poly1305. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The 32 byte key key to use for encryption. </td></tr>
    <tr><td class="paramname">plain</td><td>The plaintext. </td></tr>
    <tr><td class="paramname">data</td><td>The AAD. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ciphertext + nonce </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>As per the reference, the nonce used for the X variants are just randomly generated, and thus carted around with the return. </dd>
<dd>
The X stands for Extended, because the Nonce is 192-bits. When choosing nonces at random, it's got better security than the original ChaCha20-Poly1305, but it isn't technically standardized, so OpenSSL doesn't implement it. </dd>
<dd>
See <a href="https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction">https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
