<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UDP-WG Implementation: wireguard Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UDP-WG Implementation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">wireguard Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This namespace includes the WireGuard implementation,.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwireguard_1_1config.html">config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A WireGuard Configuration.  <a href="structwireguard_1_1config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwireguard_1_1CookiePacket.html">CookiePacket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwireguard_1_1InitPacket.html">InitPacket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial packet sent from initiator to responder.  <a href="classwireguard_1_1InitPacket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwireguard_1_1Packet.html">Packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For both security and ease of use, we want to use <a class="el" href="classcrypto_1_1string.html" title="A cryptographically secure string.">crypto::string</a> as much as possible. This makes it easy to run all our cryptographic functions on the handshake and transport, but it raises an issue in that these objects are not contiguous values in memory (Or, they are, but casting it into a character array isn't going to get you the bytes). If you tried to just cast the string and send it across the wire, you'd get garbage. Instead, we need to Serialize and Expand from a collection of crypto::strings making up a packet (Whether that be the handshake packets or transport packets), so that we can work with <a class="el" href="classcrypto_1_1string.html" title="A cryptographically secure string.">crypto::string</a>, but be able to serialize it down when we need to send it, and construct it back from bytes when receiving it. To unify this functionality, the <a class="el" href="classwireguard_1_1Packet.html" title="For both security and ease of use, we want to use crypto::string as much as possible....">Packet</a> object contains a list of <a class="el" href="classcrypto_1_1string.html" title="A cryptographically secure string.">crypto::string</a>'s in a vector and will serialize the contents of it, and construct a itself from bytes. Other objects derive from this class, and specify the size of the vector and its elements, and values to access specific parts.  <a href="classwireguard_1_1Packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwireguard_1_1ResponsePacket.html">ResponsePacket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The packet sent by the responder to the initiator during the handshake.  <a href="classwireguard_1_1ResponsePacket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwireguard_1_1Rm.html">Rm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A controlled wrapper for the secret random value used for the WireGuard cookies.  <a href="classwireguard_1_1Rm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwireguard_1_1TransportPacket.html">TransportPacket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A WireGuard packet for sending Transport Messages.  <a href="classwireguard_1_1TransportPacket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abb90d72b1708179f0c5da9ac72b83598" id="r_abb90d72b1708179f0c5da9ac72b83598"><td class="memItemLeft" align="right" valign="top">typedef struct wireguard::config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb90d72b1708179f0c5da9ac72b83598">config</a></td></tr>
<tr class="memdesc:abb90d72b1708179f0c5da9ac72b83598"><td class="mdescLeft">&#160;</td><td class="mdescRight">A WireGuard Configuration.  <br /></td></tr>
<tr class="separator:abb90d72b1708179f0c5da9ac72b83598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a380cc7af0e9f18a943cf1c9486885e36" id="r_a380cc7af0e9f18a943cf1c9486885e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a380cc7af0e9f18a943cf1c9486885e36">Handshake1</a> (<a class="el" href="classcrypto_1_1keypair.html">crypto::keypair</a> &amp;ephemeral, const <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;remote_pub, <a class="el" href="structwireguard_1_1config.html">config</a> &amp;con, <a class="el" href="classwireguard_1_1InitPacket.html">InitPacket</a> &amp;msg, const bool &amp;init, <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;C, <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;H)</td></tr>
<tr class="memdesc:a380cc7af0e9f18a943cf1c9486885e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first half of the Handshake process.  <br /></td></tr>
<tr class="separator:a380cc7af0e9f18a943cf1c9486885e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcbd3d5bc46cab050b210b64f358b6d" id="r_a2bcbd3d5bc46cab050b210b64f358b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bcbd3d5bc46cab050b210b64f358b6d">Handshake2</a> (const <a class="el" href="classcrypto_1_1keypair.html">crypto::keypair</a> &amp;init_ephemeral, const <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;remote_pub, <a class="el" href="structwireguard_1_1config.html">config</a> &amp;con, <a class="el" href="classwireguard_1_1ResponsePacket.html">ResponsePacket</a> &amp;msg, const bool &amp;init, <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;C, <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;H)</td></tr>
<tr class="memdesc:a2bcbd3d5bc46cab050b210b64f358b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete the Handshake.  <br /></td></tr>
<tr class="separator:a2bcbd3d5bc46cab050b210b64f358b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fc2fcab2ab7b11e6e536e8290eecf5" id="r_ac1fc2fcab2ab7b11e6e536e8290eecf5"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ac1fc2fcab2ab7b11e6e536e8290eecf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structwireguard_1_1config.html">config</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1fc2fcab2ab7b11e6e536e8290eecf5">Handshake</a> (const <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;remote_pub, const <a class="el" href="unionshared_1_1connection.html">connection</a> &amp;peer, const bool &amp;init, Q &amp;in, Q &amp;out, <a class="el" href="structwireguard_1_1config.html">config</a> conf={}, const bool &amp;cookie=false)</td></tr>
<tr class="memdesc:ac1fc2fcab2ab7b11e6e536e8290eecf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a WireGuard Handshake.  <br /></td></tr>
<tr class="separator:ac1fc2fcab2ab7b11e6e536e8290eecf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5037028109dca5cbfd8b697d8302369" id="r_ab5037028109dca5cbfd8b697d8302369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5037028109dca5cbfd8b697d8302369">test</a> ()</td></tr>
<tr class="memdesc:ab5037028109dca5cbfd8b697d8302369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the WireGuard Cryptographic Functions.  <br /></td></tr>
<tr class="separator:ab5037028109dca5cbfd8b697d8302369"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a11317bc43269bfc191ba60d5bd527e6a" id="r_a11317bc43269bfc191ba60d5bd527e6a"><td class="memItemLeft" align="right" valign="top"><a id="a11317bc43269bfc191ba60d5bd527e6a" name="a11317bc43269bfc191ba60d5bd527e6a"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>pair</b> = <a class="el" href="namespacecrypto.html#a935cf6839d85c0bda03ac16691ebcbee">crypto::DH_GENERATE</a>()</td></tr>
<tr class="separator:a11317bc43269bfc191ba60d5bd527e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382924b6a96af1eba4d78381646e07d5" id="r_a382924b6a96af1eba4d78381646e07d5"><td class="memItemLeft" align="right" valign="top"><a id="a382924b6a96af1eba4d78381646e07d5" name="a382924b6a96af1eba4d78381646e07d5"></a>
const <a class="el" href="classcrypto_1_1string.html">crypto::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EPSILON</b> = 32</td></tr>
<tr class="separator:a382924b6a96af1eba4d78381646e07d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38fe7e50790aad3e5ff447dcd108f03" id="r_af38fe7e50790aad3e5ff447dcd108f03"><td class="memItemLeft" align="right" valign="top"><a id="af38fe7e50790aad3e5ff447dcd108f03" name="af38fe7e50790aad3e5ff447dcd108f03"></a>
const <a class="el" href="classcrypto_1_1string.html">crypto::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CONSTRUCTION</b> = (&quot;Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s&quot;, 32)</td></tr>
<tr class="separator:af38fe7e50790aad3e5ff447dcd108f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbdbabecf7c659a0808530af02c6979" id="r_a7fbdbabecf7c659a0808530af02c6979"><td class="memItemLeft" align="right" valign="top"><a id="a7fbdbabecf7c659a0808530af02c6979" name="a7fbdbabecf7c659a0808530af02c6979"></a>
const <a class="el" href="classcrypto_1_1string.html">crypto::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IDENTIFIER</b> = (&quot;WireGuard v1 zx2c4 Jason@zx2c4.com&quot;, 34)</td></tr>
<tr class="separator:a7fbdbabecf7c659a0808530af02c6979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fbc42dc210fd2312691ae62c88fa2d" id="r_a43fbc42dc210fd2312691ae62c88fa2d"><td class="memItemLeft" align="right" valign="top"><a id="a43fbc42dc210fd2312691ae62c88fa2d" name="a43fbc42dc210fd2312691ae62c88fa2d"></a>
const <a class="el" href="classcrypto_1_1string.html">crypto::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LABEL_MAC1</b> = (&quot;mac1----&quot;, 8)</td></tr>
<tr class="separator:a43fbc42dc210fd2312691ae62c88fa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965428e28fb9d862bf292360925f333e" id="r_a965428e28fb9d862bf292360925f333e"><td class="memItemLeft" align="right" valign="top"><a id="a965428e28fb9d862bf292360925f333e" name="a965428e28fb9d862bf292360925f333e"></a>
const <a class="el" href="classcrypto_1_1string.html">crypto::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LABEL_COOKIE</b> = (&quot;cookie--&quot;, 8)</td></tr>
<tr class="separator:a965428e28fb9d862bf292360925f333e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0bf7a0268f54a88123eb54825a84c4" id="r_aec0bf7a0268f54a88123eb54825a84c4"><td class="memItemLeft" align="right" valign="top"><a id="aec0bf7a0268f54a88123eb54825a84c4" name="aec0bf7a0268f54a88123eb54825a84c4"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>REKEY_MSGS</b> = 1152921504606846976</td></tr>
<tr class="separator:aec0bf7a0268f54a88123eb54825a84c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92db9ff9c7b50bca846a6c85fc7aac33" id="r_a92db9ff9c7b50bca846a6c85fc7aac33"><td class="memItemLeft" align="right" valign="top"><a id="a92db9ff9c7b50bca846a6c85fc7aac33" name="a92db9ff9c7b50bca846a6c85fc7aac33"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>RJECT_MSGS</b> = 1.844674407370954e19</td></tr>
<tr class="separator:a92db9ff9c7b50bca846a6c85fc7aac33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8240a2f80ea199867a1e1227ae9979c5" id="r_a8240a2f80ea199867a1e1227ae9979c5"><td class="memItemLeft" align="right" valign="top"><a id="a8240a2f80ea199867a1e1227ae9979c5" name="a8240a2f80ea199867a1e1227ae9979c5"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>REKEY_TIME</b> = 120</td></tr>
<tr class="separator:a8240a2f80ea199867a1e1227ae9979c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6757d57a7f4da421ad19fd5f09677bbe" id="r_a6757d57a7f4da421ad19fd5f09677bbe"><td class="memItemLeft" align="right" valign="top"><a id="a6757d57a7f4da421ad19fd5f09677bbe" name="a6757d57a7f4da421ad19fd5f09677bbe"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>RJECT_TIME</b> = 180</td></tr>
<tr class="separator:a6757d57a7f4da421ad19fd5f09677bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae607907b156d698068c1d7c0a5b18e6e" id="r_ae607907b156d698068c1d7c0a5b18e6e"><td class="memItemLeft" align="right" valign="top"><a id="ae607907b156d698068c1d7c0a5b18e6e" name="ae607907b156d698068c1d7c0a5b18e6e"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>REKEY_TOUT</b> = 5</td></tr>
<tr class="separator:ae607907b156d698068c1d7c0a5b18e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c40768255cf6a604317caa82001af29" id="r_a7c40768255cf6a604317caa82001af29"><td class="memItemLeft" align="right" valign="top"><a id="a7c40768255cf6a604317caa82001af29" name="a7c40768255cf6a604317caa82001af29"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>KEEPALIVE</b> = 10</td></tr>
<tr class="separator:a7c40768255cf6a604317caa82001af29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1b0968a9d9710d4de3f322931b4611" id="r_a5e1b0968a9d9710d4de3f322931b4611"><td class="memItemLeft" align="right" valign="top"><a id="a5e1b0968a9d9710d4de3f322931b4611" name="a5e1b0968a9d9710d4de3f322931b4611"></a>
<a class="el" href="classwireguard_1_1Rm.html">Rm</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cookie_random</b></td></tr>
<tr class="separator:a5e1b0968a9d9710d4de3f322931b4611"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace includes the WireGuard implementation,. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This implementation was created in reference to the WireGuard Whitepaper (<a href="https://www.wireguard.com/papers/wireguard.pdf">https://www.wireguard.com/papers/wireguard.pdf</a>) herein referred to as the "Reference" </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="abb90d72b1708179f0c5da9ac72b83598" name="abb90d72b1708179f0c5da9ac72b83598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb90d72b1708179f0c5da9ac72b83598">&#9670;&#160;</a></span>config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct wireguard::config wireguard::config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A WireGuard Configuration. </p>
<dl class="section remark"><dt>Remarks</dt><dd>For every WireGuard connection, both the server and client create a config object that contains all the information needed to talk; the server supplies this to the newly spawned WG Thread, whereas the client saves it within wireguard_server value in the Main Thread. This includes everything from timestamps to indicate a rekey, identities, send/recv, the source, and cookies. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac1fc2fcab2ab7b11e6e536e8290eecf5" name="ac1fc2fcab2ab7b11e6e536e8290eecf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fc2fcab2ab7b11e6e536e8290eecf5">&#9670;&#160;</a></span>Handshake()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwireguard_1_1config.html">config</a> wireguard::Handshake </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>remote_pub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionshared_1_1connection.html">connection</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwireguard_1_1config.html">config</a></td>          <td class="paramname"><span class="paramname"><em>conf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;</td>          <td class="paramname"><span class="paramname"><em>cookie</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a WireGuard Handshake. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>queue ;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_pub</td><td>The remote's public key </td></tr>
    <tr><td class="paramname">peer</td><td>The connection to the peer. </td></tr>
    <tr><td class="paramname">init</td><td>Whether we are the initiator. </td></tr>
    <tr><td class="paramname">in</td><td>The in queue </td></tr>
    <tr><td class="paramname">out</td><td>The out queue. </td></tr>
    <tr><td class="paramname">conf</td><td>The wireguard configuration to built. </td></tr>
    <tr><td class="paramname">cookie</td><td>Whether we are sending a cookie. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function completes the entire Handshake Process for a WireGuard connection. The flow of logic is somewhat complicated: Both initiator and responder enter this function, where the responder immediately waits for the client to provide an <a class="el" href="classwireguard_1_1InitPacket.html" title="The initial packet sent from initiator to responder.">InitPacket</a>. The client stepping into Handshake1, dutifully produces that <a class="el" href="classwireguard_1_1Packet.html" title="For both security and ease of use, we want to use crypto::string as much as possible....">Packet</a>, adds some information to the configuration, and gets the working values of H and C. It then steps back to this function, where it sends the packet across, and then waits. The responder then receives this packet, and uses the populated <a class="el" href="classwireguard_1_1InitPacket.html" title="The initial packet sent from initiator to responder.">InitPacket</a> runs through Handshake1, reaching the same state as the initiator. It then steps into Handshake2, completing its part of the Handshake, producing Transport Keys that have been derived from both Static and Ephemeral of both peers, and sends the <a class="el" href="classwireguard_1_1ResponsePacket.html" title="The packet sent by the responder to the initiator during the handshake.">ResponsePacket</a> across. The client then wakes up, and uses this <a class="el" href="classwireguard_1_1ResponsePacket.html" title="The packet sent by the responder to the initiator during the handshake.">ResponsePacket</a> to run through Handshake2, ending with the same Transport Keys, and a completed configuration. </dd>
<dd>
An aside for the template: in C++, if you have a circular dependencies and you don't want there to be one, you can hand wave it away with templates. The queue is defined in <a class="el" href="network_8h_source.html">network.h</a>, and for a while this function lived in that header, but it didn't make much sense: it'S a WireGuard handshake. So, what do we do? We make the function a template, and then each instance of the Handshake called (Spoilers, it's only called with Q = <a class="el" href="classnetwork_1_1queue.html" title="A thread-safe queue.">network::queue</a>), is created by the compiler. So, we can stick Handshake here, and don't even need to explicitly provide Q in the function calls because C++ is smart enough to deduce it based on the function arguments. </dd></dl>

</div>
</div>
<a id="a380cc7af0e9f18a943cf1c9486885e36" name="a380cc7af0e9f18a943cf1c9486885e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380cc7af0e9f18a943cf1c9486885e36">&#9670;&#160;</a></span>Handshake1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wireguard::Handshake1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrypto_1_1keypair.html">crypto::keypair</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ephemeral</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>remote_pub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwireguard_1_1config.html">config</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>con</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwireguard_1_1InitPacket.html">InitPacket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>H</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first half of the Handshake process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ephemeral</td><td>The ephemeral keypairs of the peer. </td></tr>
    <tr><td class="paramname">remote_pub</td><td>The peer's public key. </td></tr>
    <tr><td class="paramname">con</td><td>The configuration that we populate for subsequent communication. </td></tr>
    <tr><td class="paramname">msg</td><td>The <a class="el" href="classwireguard_1_1InitPacket.html" title="The initial packet sent from initiator to responder.">InitPacket</a>. The initiator builds this <a class="el" href="classwireguard_1_1Packet.html" title="For both security and ease of use, we want to use crypto::string as much as possible....">Packet</a>, and then sends it to the responder, who uses the pre-populated <a class="el" href="classwireguard_1_1Packet.html" title="For both security and ease of use, we want to use crypto::string as much as possible....">Packet</a> for this function. </td></tr>
    <tr><td class="paramname">init</td><td>Whether this is the initiator. </td></tr>
    <tr><td class="paramname">C</td><td>The chaining key value. </td></tr>
    <tr><td class="paramname">H</td><td>The hash result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the handshake fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This part of the Handshake builds the <a class="el" href="classwireguard_1_1InitPacket.html" title="The initial packet sent from initiator to responder.">InitPacket</a>, or the information the initiator of the exchange sends over to the responder. Both run this function, but their behavior is different. The initiator runs through this function and populates an empty <a class="el" href="classwireguard_1_1InitPacket.html" title="The initial packet sent from initiator to responder.">InitPacket</a> msg, computing its Ephemeral Keys, and then returning the completed <a class="el" href="classwireguard_1_1InitPacket.html" title="The initial packet sent from initiator to responder.">InitPacket</a>, and the values it got for C and H. All this time, the responder is just sitting in wait for the initiator. Once the initiator finishes, they return from this function back to Handshake, where it will then send the <a class="el" href="classwireguard_1_1InitPacket.html" title="The initial packet sent from initiator to responder.">InitPacket</a> across the wire. The responsder then runs through this function (init = false), and not only performs checks to ensure that the peer is the person they're expecting, but extracts the relevant information. The way this function works such that both peers will return with the same C and H value. All this time, the initiator has been sitting, and the responder then heads into Handshake2, which is where the responder generates its own Ephemeral Keys, constructs the <a class="el" href="classwireguard_1_1ResponsePacket.html" title="The packet sent by the responder to the initiator during the handshake.">ResponsePacket</a>, and finally sends it back to the initiator. The initiator then brings this packet into Handshake2, generating the required details and verifying, and the result is a set of Transport Keys, one for receiving, one for sending, that has been generated through a combination of both the peers Static and Ephemeral Keys. </dd>
<dd>
This is based on the Noise Framework: <a href="https://noiseprotocol.org/noise.pdf">https://noiseprotocol.org/noise.pdf</a> </dd>
<dd>
This may look a little daunting (I'm sure the wall of comments probably isn't helping), but Jason, the creator of WireGuard has a really nice presentation that he has given at several conventions: <a href="https://www.wireguard.com/talks/eindhoven2018-slides.pdf">https://www.wireguard.com/talks/eindhoven2018-slides.pdf</a> It helps explain more of the protocol. </dd></dl>

</div>
</div>
<a id="a2bcbd3d5bc46cab050b210b64f358b6d" name="a2bcbd3d5bc46cab050b210b64f358b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcbd3d5bc46cab050b210b64f358b6d">&#9670;&#160;</a></span>Handshake2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wireguard::Handshake2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1keypair.html">crypto::keypair</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>init_ephemeral</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>remote_pub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwireguard_1_1config.html">config</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>con</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwireguard_1_1ResponsePacket.html">ResponsePacket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrypto_1_1string.html">crypto::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>H</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete the Handshake. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_ephemeral</td><td>The ephemeral keys the initiator created. If this is the responder, we only know the public component. </td></tr>
    <tr><td class="paramname">remote_pub</td><td>The other peer's public key. </td></tr>
    <tr><td class="paramname">con</td><td>The WireGuard configuration we're building. </td></tr>
    <tr><td class="paramname">msg</td><td>The packet to send back. If we are the initiator, this is already populated. If we're the responder, we build this before returning, and then sending it to the initiator. </td></tr>
    <tr><td class="paramname">init</td><td>Whether we are the initiator. </td></tr>
    <tr><td class="paramname">C</td><td>The chaining key value. </td></tr>
    <tr><td class="paramname">H</td><td>The hash result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function complete the Handshake we started in Handshake1, and does largely the same thing as the prior one; now, the Responder generates their Ephemeral Keys, and ties them into the chaining key and hash result, ensuring that both peer's have their Static and Ephemeral Keys tied into the eventual Transport Keys. One important difference is that the Responder's <a class="el" href="classwireguard_1_1Packet.html" title="For both security and ease of use, we want to use crypto::string as much as possible....">Packet</a> is smaller than the Initiators. Why? It's to avoid amplification attacks. The Responder cannot be flooded with small InitPackets, and send a barrage of massive packets to whatever unassuming target you've pointed the server at. </dd></dl>

</div>
</div>
<a id="ab5037028109dca5cbfd8b697d8302369" name="ab5037028109dca5cbfd8b697d8302369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5037028109dca5cbfd8b697d8302369">&#9670;&#160;</a></span>test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wireguard::test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the WireGuard Cryptographic Functions. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the system has outdated OpenSSL, or the pre-compiled version doesn't cooperate well, we should detect that as soon as possible to prevent confusing bugs down the line. </dd>
<dd>
This is probably excessive; OpenSSL has really good backward compatibility, and any version of glibc within the last decade will easily be able to handle our pre-compiled program. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
